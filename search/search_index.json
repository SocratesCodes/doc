{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SocratesCode Development Introduction","text":""},{"location":"#socratescode-development-introduction","title":"SocratesCode Development Introduction","text":"<p>SocratesCode is an AI-powered programming tutor using Socratic methodlogy, enabling programming student and educator to learn programming in a meaningful way with AI.</p> <p>Warning</p> <p>This documentation won't discuss much about how to use SocratesCode aside from few main use cases and will mainly focus on deployment and development setup.</p> <p>To get started, use the following guides as a checklist to help you host and/or develop our application:</p> <p>Before setting up those environments, you may want to check out the development reference to get a better understanding of the project structure and development workflow.</p>"},{"location":"#setup-development","title":"Setup development","text":"<ul> <li>Refer to Preparation to setup prerequisities to run our application.</li> <li>Generate PEM keys file with Openssl as described in here.</li> <li>Run our application</li> <li>Setup necessary environment variables and configuration.</li> </ul>"},{"location":"#deploy-to-your-own-server","title":"Deploy to your own server","text":"<ul> <li>See the deployment prerequisites for necessary software.</li> <li>Before deploying, view the requirements to see if our application can run on your server.</li> <li>Follow the deployment guide to deploy your application to your own server.</li> </ul> <p>After finishing the deployment/development, or if you have any trouble initializing langfuse during setup, see the langfuse guide for more details.</p>"},{"location":"#socratescode-tutorials","title":"SocratesCode Tutorials","text":"<p>Already got the application running, or have it deployed to your own server? Then, you can start to use SocratesCode to learn programming.</p> <ul> <li>Chatting with our AI tutor</li> <li>Create a new account</li> <li>Manage your account</li> </ul>"},{"location":"additional%20setup/langfuse/","title":"Monitoring and Observability","text":""},{"location":"additional%20setup/langfuse/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>Warning</p> <p>This should be done during deployment and application development.</p> <p>To ensure our application's stability and performance (especially AI service) and catch any bugs occurred, in this guide we will help you set up services that monitors our application.</p>"},{"location":"additional%20setup/langfuse/#langfuse-for-ai-monitoring","title":"Langfuse for AI monitoring","text":"<p>We used Langfuse, a cloud-based tracing and observability service that helps us see how our AI system interacts with user and its internal state.</p> <p>By the end of this section, you should be able to: - Setup Langfuse for tracing and observability - View, analyze and intepret how our AI works and its performance via Langfuse. - See the feedback from user via Langfuse.</p> <p>We will often refers to Langfuse official documentation to explain how to use the platform as well as setup it in the application.</p>"},{"location":"additional%20setup/langfuse/#setup-langfuse","title":"Setup Langfuse","text":"<ul> <li>Create an account on Langfuse</li> <li>Create a new project on Langfuse</li> <li>Get the public and secret key for the project</li> <li>Setup those keys in environment variables. See environment variables, langfuse part for more details.</li> </ul> <p>Afterward, you should try to chat with our AI and the traces in Langfuse should be visible.</p>"},{"location":"additional%20setup/langfuse/#view-the-inner-state-of-ai","title":"View the inner state of AI.","text":"<p>Our application only shows the final response from AI, thus if you are going to debug or monitor how the agent within the AI works, you will need to view the inner state of AI.</p> <ul> <li>Access the trace from Langfuse and click on the trace you want to view.</li> </ul> <p>Chat with our AI application first, then once it is done, you should be able to see the trace in Langfuse. Our trace when captured should look like this:</p> <p></p>"},{"location":"additional%20setup/langfuse/#see-the-feedback-from-user","title":"See the feedback from user","text":"<p>Our application only shows the final response from AI. Thus if you are going to debug or monitor how the agent within the AI works, you will need to view the inner state of AI.</p> <p>On our application, when message from AI system is delivered, you should see the feedback button like this: </p> <p>After clicking on it, a feedback modal with like, dislike and additional comment field will be shown:  User can select if they like the response or not, and also add additional comment if they want to. Upon completing the feedback, it will be sent to Langfuse in normal curcumstance and you should be able to see the feedback in Langfuse in the Scores section. Our feedback when displayed on Langfuse should look like this: </p> <p>You can also view this information along with the trace that user feedback on by clicking on the Trace name within the Scores section:  </p>"},{"location":"additional%20setup/langfuse/#sentry-for-service-monitoring","title":"Sentry for service monitoring","text":"<p>Doc in construction</p> <p>This section is still under construction and will be updated soon.</p>"},{"location":"additional%20setup/minio/","title":"Storing application files with MinIO","text":""},{"location":"additional%20setup/minio/#storing-application-files-with-minio","title":"Storing application files with MinIO","text":"<p>MinIO is a distributed object storage system that is compatible with the S3 API. In our project, it is used to store team state and files. This step should be done during the development or deployment setup.</p> <p>By the end of this guide, you should be able to:</p> <ul> <li>Setup MinIO locally with Podman</li> <li>Setup MinIO on your own server with Coolify.</li> </ul>"},{"location":"additional%20setup/minio/#setup-minio-locally","title":"Setup MinIO locally","text":"<p>Prerequisites</p> <p>Ensure you have installed Podman on the server. See here for more details.</p> <ol> <li> <p>Run the following command to initialize the MinIO container (change the <code>ROOTNAME</code> and <code>CHANGEME123</code> to your own and remember them as it is required for the next step): </p><pre><code>podman run \\\n   -p 9000:9000 \\\n   -p 9001:9001 \\\n   --name minio \\\n   -v ~/minio/data:/data \\\n   -e \"MINIO_ROOT_USER=ROOTNAME\" \\\n   -e \"MINIO_ROOT_PASSWORD=CHANGEME123\" \\\n   quay.io/minio/minio server /data --console-address \":9001\"\n</code></pre><p></p> For windows users <p>You may need to run the command in PowerShell. It will be a little bit different from the command above since PowerShell uses different syntax for newlines:</p> <pre><code>podman run `\n  -p 9000:9000 `\n  -p 9001:9001 `\n  --name minio `\n  -v \"$HOME/minio/data:/data\" `\n  -e \"MINIO_ROOT_USER=ROOTNAME\" `\n  -e \"MINIO_ROOT_PASSWORD=CHANGEME123\" `\n  quay.io/minio/minio server /data --console-address \":9001\"\n</code></pre> <p>Ensure you are in home directory when running the command.</p> <p>The following steps will refer <code>MINIO_ROOT_USER</code> and <code>MINIO_ROOT_PASSWORD</code> as <code>ROOTNAME</code> and <code>CHANGEME123</code> respectively.</p> </li> <li> <p>Once running, you should be able to access the MinIO console at <code>http://localhost:9001</code>. Login and create buckets for the project. One for storing team state and one for storing avatars image.</p> <p>In our guide, we will refer to these buckets as <code>json-files</code> and <code>userdata</code> respectively.</p> </li> <li> <p>Set those in your application's environment variables:</p> <ul> <li><code>MINIO_BUCKET</code> - bucket for storing user avatars.</li> <li><code>JSON_BUCKET</code> - bucket for storing json files. I</li> </ul> </li> <li> <p>Access the podman container to run commands: </p><pre><code>podman exec -it minio bash\n</code></pre><p></p> </li> <li> <p>Authenticate the <code>mc</code> client: </p><pre><code>mc alias set local http://127.0.0.1:9000 ROOTNAME CHANGEME123\n</code></pre> where ROOTNAME and CHANGEME123 are the same as the ones you used to initialize the MinIO container.<p></p> </li> <li> <p>Enable download policy for the avatars bucket. This is essential for the frontend to be able to download the avatars. </p><pre><code>mc anonymous set download local/&lt;YOUR_AVATAR_BUCKET&gt;\n</code></pre> where <code>&lt;YOUR_AVATAR_BUCKET&gt;</code> is the name of the avatars bucket you created.<p></p> </li> </ol> <p>At this point, you should be able to change profile picture, as well as AI should work properly. Additional configurations may needed (see here and preparation for more details).</p>"},{"location":"additional%20setup/minio/#setup-minio-on-your-own-server","title":"Setup MinIO on your own server","text":"<p>Prerequisites</p> <p>Ensure you have already met the minimum requirements and have your server ready. See here for more details.</p> <ol> <li>Setup Coolify on your server if you haven't already.</li> <li>Create a new resource on Coolify and select MinIO.</li> <li> <p>In MinIO docker compose file, edit its file to below: </p><pre><code>services:\n  minio:\n    image: 'quay.io/minio/minio:latest'\n    command: 'server /data --console-address \":9001\"'\n    environment:\n      # - MINIO_SERVER_URL=$MINIO_SERVER_URL\n      # - MINIO_BROWSER_REDIRECT_URL=$MINIO_BROWSER_REDIRECT_URL\n      - MINIO_ROOT_USER=$SERVICE_USER_MINIO\n      - MINIO_ROOT_PASSWORD=$SERVICE_PASSWORD_MINIO\n    volumes:\n      - 'minio-data:/data'\n    healthcheck:\n      test:\n        - CMD\n        - mc\n        - ready\n        - local\n      interval: 5s\n      timeout: 20s\n      retries: 10\n</code></pre> The main difference compared to the Coolify's template is that both <code>MINIO_SERVER_URL</code> and <code>MINIO_BROWSER_REDIRECT_URL</code> are not needed.<p></p> </li> <li> <p>Configure Service Specific Configurations to match your preferences.</p> <p>Warning</p> <p>per this, you need to run MinIO on https since it don't support http authentication.</p> <p>Also for URL, you may need a domain to access the MinIO console.</p> </li> <li> <p>Deploy the resource.</p> </li> <li>Access the MinIO console url, authenticate and then perform step 2 of the local setup above.</li> <li>Set MinIO configured credentials in your application's environment variables.</li> <li>On Coolify, access the resource container's terminal and perform step 5 and 6 of the local setup above.</li> </ol>"},{"location":"additional%20setup/minio/#whats-next","title":"What's next?","text":"<p>Check other development prerequisites guides and deployment prerequisites guides for other requirements if unmet.</p>"},{"location":"concepts/architecture/","title":"SocratesCode System Architecture Reference","text":""},{"location":"concepts/architecture/#socratescode-system-architecture-reference","title":"SocratesCode System Architecture Reference","text":""},{"location":"concepts/architecture/#application-overview","title":"Application Overview","text":"<p>SocratesCode is an AI Tutoring application that uses the Socratic method to teach programming. The system is built with a microservices architecture consisting of 3 main services: AI Service (Python/FastAPI), Backend Service (Node.js/Express), and Frontend Service (Next.js/React).</p>"},{"location":"concepts/architecture/#technology-stack","title":"Technology Stack","text":"<ul> <li>Frontend: Next.js 15.3.1 with React 19, TypeScript, Tailwind CSS</li> <li>Backend API: Node.js with Express, Socket.IO for realtime communication</li> <li>AI Service: Python 3.12 with FastAPI, AutoGen multi-agent framework</li> <li>Database: Supabase (PostgreSQL) for data persistence</li> <li>Memory/Vector Store: Mem0 for user assessment and conversation history</li> <li>File Storage: MinIO for team state and files</li> <li>Monitoring: Sentry, Langfuse for AI observability</li> <li>Authentication: JWT-based with RSA256 key pairs</li> <li>Real-time Communication: Socket.IO for chat interface and AI coordination</li> </ul>"},{"location":"concepts/architecture/#overall-architecture","title":"Overall Architecture","text":"<pre><code>graph TB\n    User[User Browser] --&gt; Frontend[Frontend Service&lt;br/&gt;Next.js:3000]\n    Frontend --&gt; Backend[Backend Service&lt;br/&gt;Node.js:5000]\n    Backend --&gt; AI[AI Service&lt;br/&gt;Python:8002]\n    Backend --&gt; DB[(Supabase PostgreSQL)]\n    AI --&gt; Memory[(Mem0 Vector Store)]\n    AI --&gt; Files[(MinIO File Storage)]\n    Backend &lt;--&gt; Socket{Socket.IO&lt;br/&gt;Real-time}\n    AI &lt;--&gt; Socket\n    Frontend &lt;--&gt; Socket\n    AI --&gt; OpenAI[OpenAI API]\n    Backend --&gt; Sentry[Sentry Monitoring]\n    AI --&gt; Langfuse[Langfuse AI Tracing]</code></pre>"},{"location":"concepts/architecture/#service-architecture","title":"Service Architecture","text":""},{"location":"concepts/architecture/#1-ai-service-pythonfastapi","title":"1. AI Service (Python/FastAPI)","text":""},{"location":"concepts/architecture/#location-ai","title":"Location: <code>/ai/</code>","text":""},{"location":"concepts/architecture/#multi-agent-tutoring-system","title":"Multi-Agent Tutoring System","text":"<ul> <li>GreetingAgent: Input gatekeeper, classifies queries into simple/CS-related/off-topic</li> <li>EvaluationAgent: Evaluates skill level, creates structured analysis with correctness_score and reasoning_score</li> <li>SocraticTutorAgent: Creates 3 Socratic questions (P1: Conceptual, P2: Analogical, P3: Practical)</li> <li>ValidationAgent: Checks response quality with detailed scoring (0-100), detects code violations</li> <li>EndNode: Terminal node for conversation flow</li> </ul>"},{"location":"concepts/architecture/#multi-agent-system-workflow","title":"Multi-Agent System Workflow:","text":"<pre><code>graph LR\n    A[User Input] --&gt; B[GreetingAgent]\n    B --&gt; C[EvaluationAgent]\n    C --&gt; D[SocraticTutorAgent]\n    D --&gt; E[ValidationAgent]\n    E --&gt; F[GreetingAgent]\n    F --&gt; G[End]</code></pre>"},{"location":"concepts/architecture/#core-components","title":"Core Components:","text":"<p>ConversationManager (<code>ai/ConversationManager.py</code>):</p> <ul> <li>Manages multiple conversations with LRU caching (max 50 conversations)</li> <li>Load/save team state from MinIO storage</li> <li>Integration with Mem0 for user memory and evaluation storage</li> <li>Handles temporary conversations (prefix <code>temp_</code>)</li> </ul> <p>Team Creation &amp; State Management:</p> <ul> <li>GraphFlow configuration with conditional routing</li> <li>Auto-save team state to MinIO after each conversation</li> <li>Memory context injection for agents from Mem0</li> </ul> <p>Real-time Communication:</p> <ul> <li>Socket.IO client connection to Backend Service</li> <li>Room-based messaging with conversation IDs</li> <li>WebSocket message filtering and processing</li> <li>Langfuse tracing for each AI stream processing</li> </ul>"},{"location":"concepts/architecture/#configuration-aimodel_configyaml","title":"Configuration (<code>ai/model_config.yaml</code>):","text":"<pre><code>orchestrator_agent:\n  provider: autogen_ext.models.openai.OpenAIChatCompletionClient\n  config:\n    model: ${MODEL_NAME}\n    api_key: ${MODEL_API_KEY}\n    temperature: 0.6\n    top_p: 0.85\n    top_k: 40\n\nvalidation_agent:\n  provider: autogen_ext.models.openai.OpenAIChatCompletionClient\n  config:\n    model: ${MODEL_NAME}\n    api_key: ${MODEL_API_KEY}\n    temperature: 0.2\n    top_p: 0.7\n    top_k: 20\n\nsocratic_tutor_agent:\n  provider: autogen_ext.models.openai.OpenAIChatCompletionClient\n  config:\n    model: ${MODEL_NAME}\n    api_key: ${MODEL_API_KEY}\n    temperature: 0.3\n\ngreeting_agent:\n  provider: autogen_ext.models.openai.OpenAIChatCompletionClient\n  config:\n    model: ${MODEL_NAME}\n    api_key: ${MODEL_API_KEY}\n    temperature: 0.4\n\nevaluation_agent:\n  provider: autogen_ext.models.openai.OpenAIChatCompletionClient\n  config:\n    model: ${MODEL_NAME}\n    api_key: ${MODEL_API_KEY}\n    temperature: 0.5\n    top_p: 0.8\n    top_k: 30\n</code></pre>"},{"location":"concepts/architecture/#file-operations-aifile_operationspy","title":"File Operations (<code>ai/file_operations.py</code>):","text":"<ul> <li>MinIO integration for team state upload/download</li> <li>Async file operations with aiofiles</li> </ul>"},{"location":"concepts/architecture/#2-backend-service-nodejsexpress","title":"2. Backend Service (Node.js/Express)","text":""},{"location":"concepts/architecture/#location-appsbackend","title":"Location: <code>/apps/backend/</code>","text":"<p>Real-time Communication Engine (<code>src/ws/webSocketServer.js</code>):</p> <ul> <li>Socket.IO server with CORS configuration</li> <li>Room-based conversation management</li> <li>Temporary conversation handling with automatic cleanup (5 minutes for leave, 1 minute for disconnect)</li> <li>Message persistence and broadcasting</li> <li>Authentication middleware with JWT verification</li> </ul> <p>API Endpoints (<code>src/routes/</code>):</p> <ul> <li>Account Management: Registration, login, logout with bcrypt password hashing</li> <li>Message API: CRUD operations with sequence numbering, conversation membership validation</li> <li>Conversation API: Create/manage conversations, title generation, participant management</li> <li>User Preferences: Skill level settings per conversation</li> <li>Notebook System: Rich text note-taking with Tiptap integration</li> <li>File Management: MinIO integration for file uploads</li> <li>User Feedback: Rating system with Langfuse trace IDs</li> </ul> <p>Security &amp; Middleware:</p> <ul> <li>JWT authentication with RSA256 key pairs</li> <li>Rate limiting with express-rate-limit</li> <li>CORS configuration for multiple origins</li> <li>Security headers and input validation</li> <li>Cookie-based token management</li> </ul> <p>Database Integration (<code>src/db/</code>):</p> <ul> <li>Supabase SDK for ORM operations</li> <li>Raw PostgreSQL queries with <code>postgres</code> library</li> <li>Connection pooling and error handling</li> </ul> <p>Services Layer (<code>src/services/</code>):</p> <ul> <li>MessageService: Message CRUD, conversation timestamp updates, AI agent message handling</li> <li>AuthService: Conversation membership validation, existence checks</li> <li>AccountService: User registration, profile management</li> <li>FileService: MinIO file operations</li> <li>CacheService: Redis-like caching layer</li> <li>ThreadService: Conversation thread management</li> </ul>"},{"location":"concepts/architecture/#3-frontend-service-nextjsreact","title":"3. Frontend Service (Next.js/React)","text":""},{"location":"concepts/architecture/#location-appsfrontend","title":"Location: <code>/apps/frontend/</code>","text":"<p>Chat Interface (<code>components/chat/</code>):</p> <ul> <li>ChatInterface.tsx: Main chat container with message display and input</li> <li>ConversationWindow.tsx: Message history with markdown rendering</li> <li>ChatInput.tsx: User input with real-time typing</li> <li>MessageFeedback.tsx: Like/dislike system with Langfuse integration</li> <li>UserPreference.tsx: Skill level selection per conversation</li> </ul> <p>Sidebar &amp; Navigation (<code>components/chat/sidebar/</code>):</p> <ul> <li>ThreadList.tsx: Conversation history with search and sort</li> <li>ThreadSearchModal.tsx: Full-text search in conversations</li> <li>DeleteThreadDialog.tsx: Confirmation dialogs for deletion</li> <li>UserAccount.tsx: Profile management</li> </ul> <p>Real-time Communication (<code>hooks/useAI.ts</code>):</p> <ul> <li>Zustand store for message state management</li> <li>Socket.IO client with reconnection logic</li> <li>Message deduplication and timestamp handling</li> <li>Status management per conversation (processing/ready/error)</li> </ul> <p>Authentication System (<code>hooks/useAuth.ts</code>):</p> <ul> <li>Zustand persistent store with localStorage</li> <li>JWT token management</li> <li>Session validation and refresh</li> <li>Guest mode support</li> </ul> <p>Thread Management (<code>hooks/useThreads.ts</code>):</p> <ul> <li>Local conversation history</li> <li>Thread filtering and sorting</li> <li>Current thread tracking</li> </ul> <p>Notebook System (<code>components/notebook/Notebook.tsx</code>):</p> <ul> <li>Tiptap rich text editor</li> <li>Real-time saving with conversation association</li> <li>Resizable panel with drag handles</li> </ul> <p>Core Page Logic (<code>app/chat/page.tsx</code>):</p> <ul> <li>AI Agent initialization with FastAPI calls</li> <li>Socket.IO connection management</li> <li>Conversation room switching</li> <li>Message history fetching</li> <li>Temporary conversation handling</li> <li>Notebook panel state management</li> </ul>"},{"location":"concepts/architecture/#4-documentation-service","title":"4. Documentation Service","text":""},{"location":"concepts/architecture/#location-appsdocs","title":"Location: <code>/apps/docs/</code>","text":"<p>Next.js-based documentation with:</p> <ul> <li>MDX content support</li> <li>Search functionality</li> <li>Responsive design</li> <li>Development guides and tutorials</li> </ul>"},{"location":"concepts/architecture/#docker-configuration","title":"Docker Configuration","text":""},{"location":"concepts/architecture/#multi-container-architecture","title":"Multi-container Architecture","text":"<pre><code># docker-compose.yml\nservices:\n  ai_service:      # Port 8002, Python/FastAPI\n  backend_service: # Port 5000, Node.js/Express  \n  frontend_service: # Port 3000, Next.js\n</code></pre>"},{"location":"concepts/architecture/#ai-service-container","title":"AI Service Container:","text":"<ul> <li>Base: Python 3.12-slim</li> <li>Dependencies: Pipenv with autogen-agentchat, langfuse, mem0ai</li> <li> <p>Build Process:</p> </li> <li> <p>Install pipenv and gcc compiler</p> </li> <li>Copy Pipfile and install dependencies</li> <li>Copy application code</li> <li>Expose port 8002</li> <li>Runtime: <code>pipenv run python app_team.py</code></li> </ul>"},{"location":"concepts/architecture/#backend-service-container","title":"Backend Service Container:","text":"<ul> <li>Base: Node.js 22-slim</li> <li> <p>Build Process:</p> </li> <li> <p>Install OpenSSL for key generation</p> </li> <li>Copy workspace configuration</li> <li>Install dependencies with <code>npm ci --workspace=apps/backend</code></li> <li>Set working directory</li> <li>Expose port 5000</li> <li>Runtime: <code>node src/index.js</code></li> <li>Key Management: RSA key pair generation in container</li> </ul>"},{"location":"concepts/architecture/#frontend-service-container","title":"Frontend Service Container:","text":"<ul> <li>Base: Node.js 22-slim</li> <li> <p>Build Process:</p> </li> <li> <p>Copy workspace files</p> </li> <li>Install dependencies with <code>npm ci --workspace=apps/frontend</code></li> <li>Run Next.js build process</li> <li>Expose port 3000</li> <li>Production: Static build with Next.js optimizations</li> </ul>"},{"location":"concepts/architecture/#container-communication","title":"Container Communication:","text":"<ul> <li>Internal Network: Docker bridge network</li> <li>Service Discovery: Container names (ai_service, backend_service, frontend_service)</li> <li>Volume Mapping: <code>./persistence:/app/apps/backend/persistence</code> for data persistence</li> </ul>"},{"location":"concepts/architecture/#detailed-code-architecture","title":"Detailed Code Architecture","text":""},{"location":"concepts/architecture/#ai-service-deep-dive","title":"AI Service Deep Dive","text":""},{"location":"concepts/architecture/#agent-workflow-implementation","title":"Agent Workflow Implementation:","text":"<p>Message Processing Pipeline (<code>ai/app_team.py:227-526</code>): </p><pre><code>@sio.event\nasync def message(raw_data):\n    # 1. Parse and validate message\n    # 2. Extract conversation_id\n    # 3. Handle temporary conversations\n    # 4. Skip non-user messages\n    # 5. Create TextMessage with enhanced context\n    # 6. Stream through multi-agent team\n    # 7. Process validation and approval flow\n    # 8. Store evaluations in Mem0\n    # 9. Save team state\n    # 10. Emit ready status\n</code></pre><p></p> <p>Team State Persistence:</p> <ul> <li>JSON serialization with datetime encoder</li> <li>MinIO upload/download with error handling</li> <li>Local file caching with team_state directory</li> <li>Conversation-specific state files: <code>team_state_{conversation_id}.json</code></li> </ul>"},{"location":"concepts/architecture/#memory-management-with-mem0","title":"Memory Management with Mem0:","text":"<p>User Assessment Storage (<code>ai/mem0_implement/MemoryManager.py</code>): </p><pre><code>class MemoryManager:\n    async def store_evaluation(user_id, conversation_id, evaluation, user_question)\n    async def get_memories(user_id, conversation_id, include_recent=True)\n</code></pre><p></p> <p>Context Enhancement (<code>ai/utils/PromptBuilder.py</code>):</p> <ul> <li>Fetch conversation history from Backend API</li> <li>Build enhanced context with user assessments</li> <li>Inject memory context into agent prompts</li> </ul>"},{"location":"concepts/architecture/#backend-service-deep-dive","title":"Backend Service Deep Dive","text":""},{"location":"concepts/architecture/#websocket-management","title":"WebSocket Management:","text":"<p>Connection Lifecycle: </p><pre><code>// Authentication middleware\nio.use((socket, next) =&gt; {\n    // JWT verification from cookie or auth header\n    // Role assignment (USER/AI/guest)\n    // User extraction and logging\n})\n\n// Room Management\nsocket.on(\"join_room\", (conversationId) =&gt; {\n    // Conversation room joining\n    // User room tracking\n    // Duplicate join prevention\n})\n</code></pre><p></p> <p>Temporary Conversation System:</p> <ul> <li>Auto-generation with UUID prefix <code>temp_</code></li> <li>5-minute cleanup timer after leave room</li> <li>1-minute cleanup timer after disconnect</li> <li>AI agent notification system</li> <li>Automatic room joining for AI agents</li> </ul>"},{"location":"concepts/architecture/#message-persistence-pipeline","title":"Message Persistence Pipeline:","text":"<p>saveMessage Function (<code>src/services/messageService.js:21-123</code>):</p> <pre><code>// 1. Validate message content and conversation membership\n// 2. Check AI agent source (orchestrator, socratic_tutor, etc.)\n// 3. Get max sequence number for ordering\n// 4. Insert into messages table with metadata\n// 5. Update conversation timestamp\n// 6. Return saved message with ID\n</code></pre>"},{"location":"concepts/architecture/#frontend-service-deep-dive","title":"Frontend Service Deep Dive","text":""},{"location":"concepts/architecture/#real-time-state-management","title":"Real-time State Management:","text":"<p>useAI Hook (<code>hooks/useAI.ts</code>):</p> <ul> <li>Zustand store with message deduplication</li> <li>Status tracking per conversation</li> <li>Socket connection state management</li> <li>Message timestamp handling</li> </ul> <p>Message Processing (<code>app/chat/page.tsx:347-405</code>): </p><pre><code>newSocket.on(\"message\", (message) =&gt; {\n    // 1. Filter system status messages\n    // 2. Ignore user echo messages\n    // 3. Filter messages from other conversations\n    // 4. Add AI messages with trace_id\n    // 5. Update conversation status\n})\n</code></pre><p></p>"},{"location":"concepts/architecture/#conversation-management","title":"Conversation Management:","text":"<p>Thread System:</p> <ul> <li>Local storage with Zustand persistence</li> <li>Conversation title generation</li> <li>Thread filtering and search</li> <li>Current thread tracking</li> </ul> <p>Message History Fetching:</p> <pre><code>const fetchMessages = async (conversationId) =&gt; {\n    // 1. Clear existing messages\n    // 2. Fetch from backend API\n    // 3. Format message structure\n    // 4. Update store state\n}\n</code></pre>"},{"location":"concepts/architecture/#security-implementation","title":"Security Implementation","text":""},{"location":"concepts/architecture/#authentication-flow","title":"Authentication Flow:","text":"<ol> <li>User Registration: Bcrypt password hashing, email verification</li> <li>Login Process: JWT token generation with RSA256 signing</li> <li>Token Storage: HttpOnly cookies + localStorage backup</li> <li>API Protection: Middleware validation on protected routes</li> <li>WebSocket Auth: Token extraction from cookies or headers</li> </ol>"},{"location":"concepts/architecture/#data-protection","title":"Data Protection:","text":"<ul> <li>Input Validation: Express-validator for API inputs</li> <li>SQL Injection: Parameterized queries with Supabase ORM</li> <li>XSS Protection: Content sanitization in markdown rendering</li> <li>CORS: Strict origin allowlist</li> <li>Rate Limiting: Express-rate-limit for API endpoints</li> </ul>"},{"location":"deployment/deployment/","title":"Deploy to your server","text":""},{"location":"deployment/deployment/#deploy-to-your-server","title":"Deploy to your server","text":"<p>To start, you will need to have your server ready with necessary software and make sure it meets the requirements.</p> <p>We recommend using official Coolify guide aside our guide to help you deploy the application and learn more about our deployment platform. See here or their official documentation for more details.</p> <ol> <li>Setup GitHub integration on Coolify</li> <li>Create a new resource on Coolify and select the repository and branch you want to deploy</li> </ol> <p>Then on the creation screen:</p> <ul> <li>Select the branch you want to deploy</li> <li>Configure docker compose file location in the repository</li> <li>Go to next step</li> <li>(Optional) Configure domain name</li> <li>Configure environment variables in the \"Environment Variables\" section of the newly created resource page.</li> <li>Click on \"Deploy\"</li> <li>Wait for the deployment to finish</li> <li>Access the application at the URL provided by Coolify</li> </ul> <p>Warning</p> <p>The first time you deploy this app, you may need to create the JWT key files in the <code>/persistence</code> folder. See here for more details.</p>"},{"location":"deployment/environment/","title":"Deployment environment variables","text":""},{"location":"deployment/environment/#deployment-environment-variables","title":"Deployment environment variables","text":"<p>This guide assumes you have already met the minimum requirements and have your server ready.</p>"},{"location":"deployment/environment/#environment-variables","title":"Environment variables","text":"<p>These are set in the Environment Variables section of the Coolify app. Make sure you have configured the project beforehand based on this guide from Coolify.</p> <p>Most of the environment variables are similar to development environment variables.</p> <p>However, there are some differences:</p> <p><code>NODE_ENV</code> for determining the environment of the backend service. Since we are on deployment, we will use <code>production</code>: </p><pre><code>NODE_ENV=production\n</code></pre><p></p> <p><code>JWT_PRIVATE_KEY_PATH</code> and <code>JWT_PUBLIC_KEY_PATH</code> for the path to the JWT key files. Given that you are using our default <code>docker-compose.yml</code> file, we had these keys stored in the <code>/persistence</code> folder. Note that those file MUST be present in the <code>/persistence</code> folder at the time of deployment. You may need to upload them to the server, have them placed in the <code>/persistence</code> folder, and redeploy the application (You only need to do this once): </p><pre><code>JWT_PRIVATE_KEY_PATH=./persistence/private_key.pem\nJWT_PUBLIC_KEY_PATH=./persistence/public_key.pem\n</code></pre><p></p> <p>Compared to local development, change those environment variables to the following: </p><pre><code>BACKEND_API_URL=http://backend_service:5000\nBACKEND_ORIGIN=http://backend_service:5000\nBACKEND_URL=http://backend_service:5000\nEXPOSED_ORIGIN=http://ai_service:8002\n</code></pre> Change the service url to the actual service url to connect to the backend service, since we are using Docker: <pre><code>NEXT_PUBLIC_AI_SERVICE_URL=http://ai_service:8002\nNEXT_PUBLIC_BACKEND_API_URL=http://backend_service:5000\n</code></pre><p></p> <p>and also change the websocket url to the actual websocket url to connect to the backend service: </p><pre><code>WEBSOCKET_URL=http://backend_service:5000\n</code></pre><p></p> <p>For MinIO, you do not need to add <code>MINIO_PORT</code>, instead use <code>MINIO_ENDPOINT</code> to connect to the MinIO service.</p>"},{"location":"deployment/intro/","title":"Introduction to deployment","text":""},{"location":"deployment/intro/#introduction-to-deployment","title":"Introduction to deployment","text":"<p>This guide section will cover the deployment of SocratesCode to your own server with proper tools and configurations.</p> <p>Note</p> <p>This guide focuses on setting up deployment with AWS as we have only have experience deploying it on this platform. Other cloud providers may work, however keep in mind that we haven't tested it yet and will not provide any support for it.</p> <p>These details will be discussed at greater detail in the following guides:</p>"},{"location":"deployment/intro/#deployment-checklist","title":"Deployment checklist","text":"<ul> <li>Check if your server meets the requirements</li> <li>Get your server ready with necessary software</li> <li>Setup MinIO (see here for more details)</li> <li>Configure necessary environment variables<ul> <li>It is similar to development environment variables for local development, but with some differences</li> </ul> </li> <li>Start deployment with our deployment guide</li> <li>Verify it works by check out some of the tutorials</li> </ul> <p>Additionally, you may also want to monitor the application in production to catch any performance issues or bugs. See here for more details.</p>"},{"location":"deployment/preparation/","title":"Prerequisites","text":""},{"location":"deployment/preparation/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes you have already met the minimum requirements and have your server ready. </p> <p>The following guide was written based on our team experience with RACE Hub (powered by AWS).</p>"},{"location":"deployment/preparation/#deployment","title":"Deployment","text":"<ul> <li>Docker</li> <li>Docker Compose</li> <li>Coolify (view here for one-command setup)</li> </ul> <p>Optionally you may also want to have an own domain name and a DNS provider if your platform doesn't support open custom ports (This can be workaround via VPC into your server, but it is required if you want to use Coolify's GitHub integration). Afterward, you should setup server URL to your own domain name if you want Coolify to accessible via your own domain name (To do this, look for \"Settings\" at the bottom left of the Coolify sidebar). Exercise caution when doing this with firewalls and other security measures.</p> <p>Warning</p> <p>Our app is designed with Coolify in mind, meaning that our docker compose file will need some adjustments to work with plain Docker deployment or other deployment platforms.</p>"},{"location":"deployment/requirements/","title":"Deployment requirements","text":""},{"location":"deployment/requirements/#deployment-requirements","title":"Deployment requirements","text":"<p>The following recommendations are based on our deployments with Coolify on the server.</p> <p>To run SocratesCode on your own server, you will need to have the following requirements ():</p> <p>We recommend using AWS m7i-flex.large instance (2 CPU, 8GB RAM).</p> <p>Otherwise, you may use the following requirements:</p> <ul> <li>AWS server with Ubuntu 22.04 LTS</li> <li>8GB RAM</li> <li>2 CPU</li> <li>64GB storage</li> </ul>"},{"location":"development/core/","title":"SocratesCode Development Reference","text":""},{"location":"development/core/#socratescode-development-reference","title":"SocratesCode Development Reference","text":"<p>This guide provides a comprehensive reference for developing SocratesCode, covering project structure, development workflow, testing strategies, and best practices.</p>"},{"location":"development/core/#development-workflow","title":"Development Workflow","text":""},{"location":"development/core/#getting-started","title":"Getting Started","text":"<p>Follow these steps to set up your development environment.</p> <p>Branch to use</p> <p>currently, the latest version is on the <code>demo</code> branch.</p>"},{"location":"development/core/#prerequisites","title":"Prerequisites","text":"<ul> <li>Git</li> <li>Python 3.11+</li> <li>Node.js 18+</li> <li>pipenv (After installed Python)</li> <li>Podman - for running MinIO locally. See here for more details.</li> </ul> <p>After install Python, you will need to install globally pipenv for managing Python dependencies and environments.</p> <p>Setup qdrant locally with the following guide: here for more details. For quick setup, below is the command to run qdrant locally: </p><pre><code>podman run -p 6333:6333 qdrant/qdrant\n</code></pre> Your server should be able to access qdrant at <code>http://localhost:6333</code>, and dashboard at <code>http://localhost:6333/dashboard</code>. You may need to change this in environment variables afterward to match the port and the qdrant url.<p></p> <p>Setup MinIO with the following guide: here for more details. For quick setup, below is the command to run MinIO locally:</p> <p>MinIO credentials</p> <p>Change the <code>ROOTNAME</code> and <code>CHANGEME123</code> to your own and keep them somewhere safe as it is required for the next step.</p> <p>Folder for MinIO data</p> <p>Create a folder for MinIO data. In this guide, we will use <code>~/minio/data</code> as the folder for MinIO data. (This will refers to your home directory. Create it if it doesn't exist.)</p> <pre><code>podman run \\\n   -p 9000:9000 \\\n   -p 9001:9001 \\\n   --name minio \\\n   -v ~/minio/data:/data \\\n   -e \"MINIO_ROOT_USER=ROOTNAME\" \\\n   -e \"MINIO_ROOT_PASSWORD=CHANGEME123\" \\\n   quay.io/minio/minio server /data --console-address \":9001\"\n</code></pre> <p>For windows users</p> <p>Use the following command instead (run via PowerShell):</p> <pre><code>podman run `\n   -p 9000:9000 `\n   -p 9001:9001 `\n   --name minio `\n   -v ~/minio/data:/data `\n   -e \"MINIO_ROOT_USER=ROOTNAME\" `\n   -e \"MINIO_ROOT_PASSWORD=CHANGEME123\" `\n   quay.io/minio/minio server /data --console-address \":9001\"\n</code></pre> <p>Given you followed the exact command above, you should be able to access the MinIO console at <code>http://localhost:9001</code>. Login and create buckets for the project. One for storing team state and one for storing avatars image. Remember the names of the buckets as they will be used in the next step. For default one, you should create two buckets: <code>json-files</code> for storing team state and <code>avatars</code> for storing avatars image.</p> <p>Then access the podman container to run commands: </p><pre><code>podman exec -it minio bash\n</code></pre><p></p> <p>Authenticate the <code>mc</code> client: </p><pre><code>mc alias set local http://127.0.0.1:9000 ROOTNAME CHANGEME123\n</code></pre><p></p> <p>Enable download policy for the avatars bucket. This is essential for the frontend to be able to download the avatars.</p> <p></p><pre><code>mc anonymous set download local/&lt;YOUR_AVATAR_BUCKET&gt;\n</code></pre> where <code>&lt;YOUR_AVATAR_BUCKET&gt;</code> is the name of the avatars bucket you created. Default one is <code>avatars</code>.<p></p>"},{"location":"development/core/#set-up-environment-variables","title":"Set up environment variables","text":"<p>Set those environment variables as described in Environment Variables based on the prerequisites you have created/installed.</p>"},{"location":"development/core/#development-commands","title":"Development Commands","text":"<p>View setup for detailed guide on how to run our application locally.</p> <ol> <li>In your desired folder, clone the repository: <pre><code>git clone https://github.com/SocratesCodes/socratescode.git\ngit checkout demo # checkout to demo branch to get the latest version\n</code></pre></li> <li> <p>Navigate to the project directory: </p><pre><code>cd socratescode\n</code></pre> Or open it in your favorite IDE then open the terminal to continue to the next step.<p></p> </li> <li> <p>Install project dependencies and have pipenv environment created with dependencies installed: </p><pre><code>npm install\n</code></pre>    Our project is a monorepo, so doing this will install all dependencies for backend, frontend and AI.<p></p> </li> <li> <p>Create an <code>.env</code> file in following places: <code>/ai/</code> folder (for AI service), <code>/apps/backend/</code> folder (for backend service) and <code>/apps/frontend/</code> folder (for frontend service)</p> </li> <li>Generate PEM keys file with Openssl as described in here.</li> <li>Setup necessary <code>.env</code> variables with environments variable guides</li> <li>Start the development server: <pre><code>npm run dev\n</code></pre></li> </ol> <p>Visit http://localhost:3000 to access the frontend page.</p>"},{"location":"development/core/#development-environment-urls","title":"Development Environment URLs","text":"<p>Change those ports to 5001 if you are using macOS. See here for more details.</p> <ul> <li>Frontend: http://localhost:3000</li> <li>Backend API: http://localhost:5000/api/health</li> <li>API Documentation: http://localhost:5000/api-docs</li> <li>AI Service: http://localhost:8002/health</li> </ul>"},{"location":"development/environment/","title":"Environment configuration","text":""},{"location":"development/environment/#environment-configuration","title":"Environment configuration","text":"<p>Warning</p> <p>Before filling in the environment variables, make sure you have created the <code>.env</code> file in the <code>/ai/</code>, <code>/apps/backend/</code> and <code>/apps/frontend/</code> folders and have setup project prerequisites as described in Preparation.</p> <p>Work in progress</p> <p>This guide is still under development. Although at the moment the following guide should be enough to get you started, we will be updating it in the future as some of the features are still in development and these will be required to be configured.</p> <p>for macos users</p> <p>In these example we used port 5000 for backend service. This port is already in use by the macOS system. You will need to change the port to 5001. If you want to use this port, you may need to disable Airplay Receiver, a macOS service. See here for more details.</p>"},{"location":"development/environment/#ai-service","title":"AI service","text":"<p>These below configurations will be used in the <code>.env</code> file in the <code>/ai/</code> folder.</p> <p>We used OpenAI API, as well as Mem0 for memory management. To configure those, fill in the following environment variables within the <code>.env</code> file in the <code>/ai/</code> folder:</p> <pre><code>OPENAI_API_KEY=\nMEM0_API_KEY=\n</code></pre> <p>For observation, we use Langfuse for tracing. Since it is cloud provider (in our case, but you can self-host it albeit we can't guarantee the stability of the service), its URL and API key are required: </p><pre><code>LANGFUSE_PUBLIC_KEY=\nLANGFUSE_SECRET_KEY=\nLANGFUSE_HOST=\n</code></pre><p></p> <p>With Autogen orchestrating the agents, we will need to fill the model name and its API key. This will be used to determine the model to use for the AI service configured via <code>model_config.yaml</code> file in the <code>/ai/</code> folder.</p> <p>Additionally, tracing level will also need to be configured. We recommend using the provided setting for better observability.</p> <pre><code>MODEL_NAME= # model name\nMODEL_API_KEY= # model api key\nAUTOGEN_DISABLE_RUNTIME_TRACING=true  # disable runtime tracing\n</code></pre> <p>Regarding model that can be used</p> <p>Currently we have only tested with OpenAI models. Other models supports are available with Autogen. Check out here for more details and see if your model is supported.</p> <p>MinIO as file storage for storing team state. Below are the configurations we have used during development: </p><pre><code>JSON_BUCKET=json-files # json files bucket\nUSER_DATA_BUCKET=userdata # user data bucket\nMINIO_DEFAULT_REGION=us-east-1 # default region\n</code></pre><p></p> <p>Qdrant for vector database assumed you have setup qdrant locally: </p><pre><code>QDRANT_HOST=localhost\nQDRANT_URL=localhost\nQDRANT_TIMEOUT_SECONDS=30\nQDRANT_PREFIX=\nQDRANT_DEBUG=1\nQDRANT_PORT=6333\nQDRANT_API_KEY=\n</code></pre> Update those configurations to match the qdrant you have setup.<p></p>"},{"location":"development/environment/#backend-service","title":"Backend service","text":"<p>These below configurations will be used in the <code>.env</code> file in the <code>/apps/backend/</code> folder for running backend service.</p> <p>Server port for running backend service - default is 5000: </p><pre><code>SERVER_PORT=5000 # server port\n</code></pre><p></p> <p>For persisting the JWT key file, the following configurations will be used for finding the defined path to make sure authentication and user related operations are working properly: </p><pre><code>JWT_PRIVATE_KEY_PATH= # private key path\nJWT_PUBLIC_KEY_PATH= # public key path\n</code></pre><p></p> <p>Warning</p> <p>Make sure the defined path for the JWT key file is correct and the file exists.</p> <p>On cloud service, you may want to keep those key files in docker volume instead of local file system. We have already defined the volume in the <code>docker-compose.yml</code> file, specifically <code>persistence</code> folder, so if you don't have any other preference, you can use that.</p> <p>Supabase for handling database and authentication. Get your url and api key from your Supabase project and then fill in the following environment variables: </p><pre><code>SUPABASE_URL= # supabase url\nSUPABASE_API_KEY= # supabase api key\n</code></pre><p></p> <p>MinIO for file storage: </p><pre><code>MINIO_ENDPOINT= # endpoint\nMINIO_USE_SSL= # true or false - true if you are using SSL, false if you are not\nMINIO_ACCESS_KEY= # access key\nMINIO_SECRET_KEY= # secret key\nMINIO_BUCKET= # avater bucket\nMINIO_PORT= # port, default is 9000\n</code></pre><p></p> <p>You should have already setup the MinIO (see here for more details). After that, you should set the following environment variables:</p> <pre><code>MINIO_BUCKET= # avater bucket\nJSON_BUCKET= # json files bucket\n</code></pre> <p>For MinIO local development</p> <p>We currently had only tested MinIO with version deployed on the cloud (see here). Hosting MinIO locally haven't tested and we can't guarantee it will work.</p> <p>OpenAI API key for using OpenAI API-related features in our backend service:</p> <pre><code>OPENAI_API_KEY=\n</code></pre> <p>Finally, <code>NODE_ENV</code> for determining the environment of the backend service. Since we are on local development, we will use <code>development</code>: </p><pre><code>NODE_ENV=development\n</code></pre><p></p>"},{"location":"development/environment/#frontend-service","title":"Frontend service","text":"<p>These below configurations will be used in the <code>.env</code> file in the <code>/apps/frontend/</code> folder for running frontend service. </p><pre><code>NEXT_PUBLIC_SUPABASE_URL= # supabase url\nNEXT_PUBLIC_SUPABASE_ANON_KEY= # supabase anon key\n</code></pre><p></p> <p>You need to configure Supabase for some functions to work properly. Get your url and api key from your Supabase project and then fill in the following environment variables.</p> <p>Then set the backend API URL. Since we are on local development, we will use <code>http://localhost:5000</code>. </p><pre><code>NEXT_PUBLIC_BACKEND_API_URL=http://localhost:5000\n</code></pre><p></p>"},{"location":"development/keys/","title":"Generate keys with openssl","text":""},{"location":"development/keys/#generate-keys-with-openssl","title":"Generate keys with openssl","text":"<p>To generate the PEM keys, you can use the following commands with OpenSSL:</p> <p>Before you start</p> <p>Make sure to keep your private key secure and do not share it with anyone. The public key can be shared freely.</p> <p>Before running this, ensure you have OpenSSL installed on your machine. You can check by running <code>openssl version</code> in your terminal. If it's not installed, you can download it from here. In addition, make sure your terminal is in the directory where you want to store the keys in the commands below.</p> <pre><code>  openssl genpkey -algorithm RSA -out \"./private_key.pem\" -pkeyopt rsa_keygen_bits:2048\n  openssl rsa -pubout -in \"./private_key.pem\" -out \"./public_key.pem\"\n</code></pre> <p>After generating the keys, you can continue to setup the development environment.</p>"},{"location":"development/preparation/","title":"Prepare your local development environment","text":""},{"location":"development/preparation/#prepare-your-local-development-environment","title":"Prepare your local development environment","text":"<p>To prepare your local development environment, you will need to install the following prerequisites and configure the following cloud services.</p> <p>Note</p> <p>Some of these services will be required to be configured. See Environment Variables for more details.</p>"},{"location":"development/preparation/#prerequisites","title":"Prerequisites","text":"<p>You will need the following tools installed on your local development machine:</p> <ul> <li>Git</li> <li>Python 3.11+</li> <li>Node.js 18+</li> <li>pipenv (After installed Python)</li> <li>Podman - for running MinIO locally</li> </ul> <p>After install Python, you will need to install globally pipenv for managing Python dependencies and environments.</p> <p>For qdrant, simply run the following command given you have installed Podman: </p><pre><code>podman run -p 6333:6333 qdrant/qdrant\n</code></pre> Your server should be able to access qdrant at <code>http://localhost:6333</code>, and dashboard at <code>http://localhost:6333/dashboard</code>. You may need to change this in environment variables afterward to match the port and the qdrant url.<p></p>"},{"location":"development/preparation/#cloud-services","title":"Cloud services","text":"<p>Beside local, there are several cloud services that you will need to configure to run SocratesCode:</p> <ul> <li>OpenAI API Key: You will need an OpenAI API key to use the AI features of SocratesCode. You can get an API key by signing up for an account on the OpenAI website.</li> <li>Supabase: You will need a Supabase account to use the database and authentication</li> <li>Mem0: A Mem0 account is required to use the memory features of SocratesCode. You can sign up for a free account on the Mem0 website.</li> <li>Langfuse: A Langfuse account is required to use the tracing features of SocratesCode. You can sign up for a free account on the Langfuse website.</li> <li>MinIO: File storage, s3-compatible object storage which is used for storing team state and files. See here for how to setup MinIO.</li> </ul> <p>After completing all of the above, you should be able to start running our application locally.</p>"},{"location":"development/setup/","title":"Spin up local development environment","text":""},{"location":"development/setup/#spin-up-local-development-environment","title":"Spin up local development environment","text":"<p>Warning</p> <p>Before starting, ensure you have necessary prerequisites and have configured the necessary cloud services as described in Preparation.</p> <p>To set up your local development environment, follow these steps:</p> <ol> <li> <p>In your desired folder, clone the repository: </p><pre><code>git clone https://github.com/SocratesCodes/socratescode.git\ngit checkout demo # checkout to demo branch to get the latest version\n</code></pre><p></p> Validate the project structure <p>After cloning, ensure the project structure looks like this: </p><pre><code>    socratescode/\n    \u251c\u2500\u2500 ai/\n    \u251c\u2500\u2500 apps/\n    \u2502   \u251c\u2500\u2500 backend/\n    \u2502   \u251c\u2500\u2500 docs/\n    \u2502   \u2514\u2500\u2500 frontend/\n    \u251c\u2500\u2500 .gitignore\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 ...\n</code></pre><p></p> </li> <li> <p>Navigate to the project directory: </p><pre><code>cd socratescode\n</code></pre> Or open it in your favorite IDE then open the terminal to continue to the next step.<p></p> </li> <li> <p>Install project dependencies and have pipenv environment created with dependencies installed: </p><pre><code>npm install\n</code></pre>    Our project is a monorepo, so doing this will install all dependencies for backend, frontend and AI.<p></p> </li> <li> <p>Create an <code>.env</code> file in following places: <code>/ai/</code> folder (for AI service), <code>/apps/backend/</code> folder (for backend service) and <code>/apps/frontend/</code> folder (for frontend service)</p> </li> <li>Generate PEM keys file with Openssl as described in here.</li> <li>Setup necessary <code>.env</code> variables with environments variable guides</li> <li> <p>Start the development server: </p><pre><code>npm run dev\n</code></pre><p></p> Running separate services <p>If you don't want to run all services concurrently, you can run each service separately by running the following commands: </p><pre><code>npm run dev:backend # run this only if you want to run backend service\nnpm run dev:frontend # run this only if you want to run frontend service\nnpm run dev:ai # run this only if you want to run AI service\n</code></pre><p></p> </li> </ol> <p>This will start all server development servers concurrently.   !!! warning \"Warning\"       Ensure you have set up all necessary environment variables in the <code>.env</code> files before starting the development server to avoid any possible bugs that stem from misconfiguration.</p> <p>Now that you have set up the development environment and run the whole application stack, you can begin using SocratesCode for testing, development or simply just use it. To validate the development environment, you can visit localhost:3000 to access the frontend page. </p>"},{"location":"development/setup/#what-to-do-from-here","title":"What to do from here","text":"<p>After setting up the development environment, you should try out some of the tutorials and make sure everything is working as expected.</p> <p>Ready to deploy to your own server? See Deployment for more details.</p>"},{"location":"tutorial/auth/","title":"SocratesCode Authentication","text":""},{"location":"tutorial/auth/#socratescode-authentication","title":"SocratesCode Authentication","text":"<p>This guide will cover the authentication feature of SocratesCode.</p> <p>This guide assumes you have already setup/deployed the application. See here for more details.</p>"},{"location":"tutorial/auth/#create-a-new-account","title":"Create a new account","text":"<p>On the homepage:</p> <ul> <li>Click on the 'Create Account' button</li> <li>Fill in the required information<ul> <li>When setting the password, ensure that it mets all the requirements displayed on the page. We have a guide to help you set password directly on the page, and it will show a green checkmark for each criteria that is met.</li> </ul> </li> <li>Click on the 'Sign Up' button</li> </ul> <p>You should be redirected to the 'Chat' page, with your account name displayed on the left bottom corner of the sidebar.</p>"},{"location":"tutorial/chatting/","title":"Chatting with our AI tutor","text":""},{"location":"tutorial/chatting/#chatting-with-our-ai-tutor","title":"Chatting with our AI tutor","text":"<p>This guide will cover the chatting feature of SocratesCode.</p> <p>This guide assumes you have already setup/deployed the application and have a user account. See here for more details.</p>"},{"location":"tutorial/chatting/#send-message-to-ai-tutor","title":"Send message to AI tutor","text":"<p>This can be used regardless of whether you have logged in or not. However, it is recommended to log in to use the full features of SocratesCode.</p> <ol> <li>Go to 'Chat' page</li> <li>Type something in the chat page's input field</li> <li>Click on the send button to send your message</li> </ol> <p>AI should display a status indicator and start to process your message and you should see the response from AI after a while.</p>"},{"location":"tutorial/chatting/#create-your-own-thread","title":"Create your own thread","text":"<p>For user who wants to go beyond chatting with our AI temporarily, you can create your own thread. SocratesCode will save your conversation thread and its history and you can come back to it at any time.</p> <p>It is similar to chatting with our AI tutor, the only difference is that you need to create a thread first before doing so via \"New Thread\" button located on the top right corner of the sidebar. The thread should be created afterwards, and you should see the thread in the thread list with custom name relevant to your query generated.</p>"},{"location":"tutorial/intro/","title":"Introduction to SocratesCode","text":""},{"location":"tutorial/intro/#introduction-to-socratescode","title":"Introduction to SocratesCode","text":"<p>This guide will help you get started with SocratesCode and understand the basic features and how to use them.</p>"},{"location":"tutorial/intro/#features","title":"Features","text":"<ul> <li>Chatting with our AI tutor</li> <li>Create a new account</li> <li>Manage your account</li> <li>Chat with AI</li> <li>Manage your notebooks</li> <li>Use threads to save your conversation</li> </ul>"},{"location":"tutorial/notebook/","title":"Notebook","text":""},{"location":"tutorial/notebook/#notebook","title":"Notebook","text":"<p>This guide will cover the notebook feature of SocratesCode.</p> <p>This guide assumes you have already setup/deployed the application and have a user account. See here for more details.</p>"},{"location":"tutorial/notebook/#using-the-notebook","title":"Using the notebook","text":"<ol> <li>Go to 'Chat' page</li> <li>Create a thread by clicking on the 'New Thread' button.<ul> <li>this is necessary to create a notebook that bounds with you and your conversation.</li> </ul> </li> <li>Click on the 'Notebook' button</li> <li>Click on the 'New Notebook' button</li> <li>Type something in the input field</li> <li>Set a name</li> </ol> <p>Next time you reload the page, you should see the notebook you have already created.</p>"},{"location":"tutorial/profile/","title":"Profile management","text":""},{"location":"tutorial/profile/#profile-management","title":"Profile management","text":"<p>This guide will cover the profile management of SocratesCode.</p> <p>Warning</p> <p>Ensure you have already deployed/setup the application and have a user account. See here for more details.</p>"},{"location":"tutorial/profile/#change-the-profile-picture","title":"Change the profile picture","text":"<ol> <li>Go to 'Chat' page</li> <li>Click on the user name on the left bottom corner of the sidebar</li> <li>Click on the 'Profile' tab</li> <li>Select the camera icon on the profile picture, and choose an image you want to set as your profile picture</li> <li>Edit your profile picture to fit the cropped area.</li> <li>Click on the 'Save' button to save your profile picture.</li> </ol> <p>It should change your profile picture on reload if there is a notification bubble indicating that your profile picture has been updated.</p>"}]}